// src/app/api/username/check/route.ts
export const runtime = "nodejs";
export const dynamic = "force-dynamic";
export const revalidate = 0;

import { NextResponse } from "next/server";
import { PrismaClient } from "@prisma/client";

/* ----------------------------- Prisma singleton ---------------------------- */
const g = globalThis as unknown as { __qsPrisma?: PrismaClient };
export const prisma = g.__qsPrisma ?? new PrismaClient();
if (!g.__qsPrisma) g.__qsPrisma = prisma;

/* ------------------------------ Tiny rate limit ---------------------------- */
const rlStore = new Map<string, { count: number; resetAt: number }>();
const RL_MAX = 15;
const RL_WINDOW_MS = 60 * 1000;
function rateLimitTry(key: string) {
  const now = Date.now();
  const cur = rlStore.get(key);
  if (!cur || now >= cur.resetAt) {
    rlStore.set(key, { count: 1, resetAt: now + RL_WINDOW_MS });
    return { success: true };
  }
  if (cur.count >= RL_MAX) return { success: false };
  cur.count += 1;
  return { success: true };
}

/* --------------------------------- helpers --------------------------------- */
function noStore(json: unknown, init?: ResponseInit) {
  const res = NextResponse.json(json, init);
  res.headers.set("Cache-Control", "no-store, no-cache, must-revalidate");
  res.headers.set("Pragma", "no-cache");
  res.headers.set("Expires", "0");
  return res;
}

const USERNAME_RE = /^[a-zA-Z0-9._]{3,24}$/;

/* ---------------------------------- GET ---------------------------------- */
export async function GET(req: Request) {
  try {
    // per-IP RL (15/min)
    const xf =
      req.headers.get("x-forwarded-for") ??
      req.headers.get("x-vercel-forwarded-for") ??
      "";
    const ip =
      (xf && xf.split(",")[0]?.trim()) ||
      req.headers.get("x-real-ip") ||
      "0.0.0.0";
    const rl = rateLimitTry(`username-check:${ip}`);
    if (!rl.success) return noStore({ error: "Too many requests" }, { status: 429 });

    const url = new URL(req.url);
    const raw = (url.searchParams.get("u") ?? url.searchParams.get("username") ?? "").trim();

    if (!raw) {
      return noStore({ available: false, valid: false, normalized: "", reason: "empty" });
    }

    const normalized = raw; // keep casing; compare case-insensitive in DB
    if (!USERNAME_RE.test(normalized)) {
      return noStore({ available: false, valid: false, normalized, reason: "invalid" });
    }

    // Who is asking? (their current username counts as available)
    let meId: string | undefined;
    try {
      // runtime import shim so TS doesnâ€™t try to resolve "@/auth"
      const _import = (Function("return import")() as unknown) as (s: string) => Promise<any>;
      const mod = await _import("@/auth").catch(() => null);
      const session = await mod?.auth?.();
      meId = (session as any)?.user?.id as string | undefined;
    } catch {
      /* treat as guest */
    }

    const existing = await prisma.user.findFirst({
      where: { username: { equals: normalized, mode: "insensitive" } },
      select: { id: true },
    });

    const available = !existing || (!!meId && existing.id === meId);
    return noStore({ available, valid: true, normalized });
  } catch (e) {
    // eslint-disable-next-line no-console
    console.warn("[/api/username/check] error:", e);
    return noStore({ error: "Server error" }, { status: 500 });
  }
}
